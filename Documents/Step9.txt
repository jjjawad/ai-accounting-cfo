Step 9.1 — Verify Storage Bucket & Service Role Access
Description:
- Confirm Supabase storage bucket (`documents` per Master Doc Step 1.7) exists and is accessible via service role. Add missing bucket creation SQL if needed and document env vars required for upload (bucket name, region/path).
Expected Output:
- Storage bucket confirmed/created; env config documented in `supabase/README.md` or backend env helper.
Testing Instructions:
- Use Supabase dashboard or CLI to list buckets; ensure `documents` (or chosen name) exists. If created via SQL, re-run `supabase db push` and verify in dashboard.
Dependencies:
- Step 1.7 (storage defaults), Step 7 (backend scaffold), Step 8 (schema in place).

Step 9.2 — Add Backend Storage Client Utility
Description:
- Implement a storage helper (e.g., `backend/lib/storage.ts`) wrapping Supabase storage upload/sign operations with typed responses and configurable bucket name.
Expected Output:
- Helper exposes functions like `uploadFile(buffer, path, contentType)` and `getPublicUrl(path)` with error handling.
Testing Instructions:
- Unit-smoke via `npm run test` (if available) or temporary script calling the helper with a small buffer; ensure upload succeeds and URL is returned/accessible.
Dependencies:
- Step 9.1 (bucket), Step 7.2 (Supabase client), Step 7.4 (responses).

Step 9.3 — Implement Authenticated File Upload API (POST /api/files/upload)
Description:
- Replace placeholder route to accept multipart form-data: fields `file`, `company_id`, optional `type`. Validate size/content-type, enforce auth/company scope, stream to storage via helper, and return file metadata + ID.
Expected Output:
- Route saves file in storage under `/company_id/{uuid}/original_filename`, creates DB row in `files` table (Step 8.5), returns `{ file_id, status: "uploaded" }`.
Testing Instructions:
- Run `npm run dev` backend; `curl -F "file=@sample.pdf" -F "company_id=..." -H "Authorization: Bearer dummy"` and verify storage object exists and DB row inserted.
Dependencies:
- Steps 7.5 (placeholder), 8.5 (files table), 9.2 (storage helper), 7.3 (auth stub).

Step 9.4 — Add File Status & Metadata Updates on Upload
Description:
- Ensure `files` row captures type, status (`uploaded`), size, mime, and source (`user_upload`). Add DB update logic in upload handler.
Expected Output:
- DB rows populated with status/metadata fields; schema constraints satisfied.
Testing Instructions:
- After upload, query `files` table (Supabase dashboard/SQL) to confirm status, size, mime, and type stored correctly.
Dependencies:
- Step 9.3, Step 8.5 schema fields.

Step 9.5 — Implement Process Endpoint to Trigger n8n/Worker
Description:
- Update `/api/files/:id/process` to look up file, validate ownership/status, and POST to configured n8n webhook (env). Mark status `processing_started` (or queued) in DB.
Expected Output:
- Endpoint queues processing and updates file status/timestamps; returns 202-style JSON.
Testing Instructions:
- Call process endpoint for an uploaded file; verify DB status update and outbound webhook fired (inspect n8n logs or request bin).
Dependencies:
- Step 9.3 (upload path), Step 7.11 (webhook placeholder), env for n8n URL/key.

Step 9.6 — Wire Frontend Documents Upload UI to API
Description:
- Connect Documents page upload zone to call `/api/files/upload`, showing progress, success, and error states. Include company_id from context and refresh list on success (mock list acceptable for now).
Expected Output:
- Drag/drop or file picker triggers real upload; user sees loading and success message; list updates to include uploaded file metadata (even mock).
Testing Instructions:
- In browser, upload a file; observe network call to `/api/files/upload`, success toast/state, and list update. Check console for absence of errors.
Dependencies:
- Step 4.3 (UI), Step 5 (company context), Step 9.3 (API).

Step 9.7 — Add Basic Client-Side Validation & Size Limits
Description:
- Enforce max file size and allowed MIME types client-side before calling API; display friendly error messages.
Expected Output:
- Upload button disabled or errors shown when invalid file selected; no network call for invalid inputs.
Testing Instructions:
- Attempt to upload an oversized or unsupported file; ensure UI blocks and shows error, and no request is sent.
Dependencies:
- Step 9.6.

Step 9.8 — Add Server-Side Validation & Error Responses
Description:
- Mirror limits server-side: reject oversized/invalid MIME with 400 using response helpers; ensure auth errors return 401/403; log failures.
Expected Output:
- Upload endpoint responds with clear JSON errors and appropriate HTTP codes for invalid input or unauthorized access.
Testing Instructions:
- `curl` without auth → 401/403; with wrong mime/size → 400; with valid file → 200. Verify DB unchanged on failed attempts.
Dependencies:
- Steps 9.3–9.5, 7.4 (responses).

Step 9.9 — Persist File-to-Company Audit Log
Description:
- Insert a system log entry (Step 8.11) on successful upload and process trigger, capturing company_id, user_id, file_id, action, and status.
Expected Output:
- `system_logs` table receives entries for upload/process events with correct metadata.
Testing Instructions:
- After upload and process, query `system_logs` to confirm entries exist with proper fields.
Dependencies:
- Step 8.11 (system_logs), Steps 9.3–9.5.

Step 9.10 — Update Build Log & Cleanup TODOs
Description:
- Document Step 9 completion in `buildlog.md`; remove temporary console logs/test code added during upload wiring.
Expected Output:
- `buildlog.md` updated with Step 9 summary; clean code without temp artifacts.
Testing Instructions:
- Run `npm run lint` front/back; ensure clean output and build passes; confirm buildlog entry present.
Dependencies:
- Steps 9.1–9.9.
