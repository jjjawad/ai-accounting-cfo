Step 7.1 — Create Backend Utility & Response Helpers
Description:

* Set up a small shared backend utilities module for API handlers: consistent JSON response helpers, error types, and a standard `{ error, code, details }` shape aligned with the Master Document’s API contracts. 
* This keeps all later endpoints using the same success/error format.
  Expected Output:
* A `backend/server/api/_utils/` (or similar) folder with:

  * `responses.ts` containing `ok()`, `badRequest()`, `unauthorized()`, `notFound()`, `serverError()` helpers.
  * `types.ts` defining a base `ApiResponseError` and `ApiHandler` type compatible with Next.js route handlers.
* No behavior change yet in the app; just utilities ready to be imported.
  Testing Instructions:
* Import one helper into a trivial test route (e.g. `/api/ping`) and verify that `ok({ message: "pong" })` returns exactly the JSON shape you expect in the browser or Postman.
  Dependencies:
* Step 1 (project initialized, TypeScript working). 
* Step 2 (backend folder structure created).

---

Step 7.2 — Add Supabase Server Client Helper
Description:

* Create a centralized server-side Supabase client for API routes using service-role or anon keys from environment variables, following the Supabase backend integration described in the Master Document. 
* Encapsulate client creation so all endpoints call a single helper.
  Expected Output:
* A `backend/lib/supabase/server-client.ts` (or similar) exporting a `getSupabaseServerClient()` function that:

  * Reads Supabase URL and service key from `process.env`.
  * Returns a configured Supabase client instance.
* No functional endpoints yet, but imports compile.
  Testing Instructions:
* Create a temporary test route `/api/debug-supabase` that calls `getSupabaseServerClient()` and returns `{ ok: true }` if the client is created without throwing.
* Hit the route; verify 200 response and no runtime errors.
  Dependencies:
* Step 1 (.env with Supabase URL and keys). 
* Step 7.1 (response helpers available for consistent output).

---

Step 7.3 — Implement Auth Extraction & Guard Helpers
Description:

* Implement backend helpers to:

  * Extract the current user from Supabase Auth (from cookies/headers).
  * Enforce that most API routes require an authenticated user, as per the multi-tenant auth model. 
* These are lightweight now (no membership table lookups yet; those come after DB schema in Step 8).
  Expected Output:
* A `backend/lib/auth/server-auth.ts` (or similar) exporting:

  * `getAuthenticatedUser(request)`: returns `{ userId, email }` or `null`.
  * `requireUser(request)`: throws or returns an Unauthorized response via helpers when no user is found.
* Simple types/interfaces for `AuthenticatedUser`.
  Testing Instructions:
* Create a test route `/api/auth-test` that calls `requireUser()` and:

  * Returns 401 when no valid session is present.
  * Returns 200 with the authenticated user’s email when logged in.
* Confirm behavior by testing in an authenticated vs non-authenticated browser session.
  Dependencies:
* Step 3 (Supabase auth set up on frontend + basic session handling). 
* Step 7.2 (server Supabase client available).

---

Step 7.4 — Scaffold File Upload & Processing API Routes
Description:

* Create placeholder implementations for the file ingestion endpoints described in the Master Document:

  * `POST /api/files/upload`
  * `POST /api/files/:id/process` 
* For now they should only: authenticate user, parse basic input, and return a “not implemented yet” response.
  Expected Output:
* Route files under `backend/server/api/files/` (or Next.js `app/api/files/`) with handlers:

  * `POST /api/files/upload`: validates that the request is authenticated and includes required fields, then returns `{ status: "stubbed" }`.
  * `POST /api/files/[id]/process`: verifies auth + `id` param, returns `{ status: "stubbed" }`.
* All routes use the shared response + auth helpers.
  Testing Instructions:
* From the browser or an API client:

  * Hit `/api/files/upload` without auth → expect 401.
  * Hit with auth but without required form-data/body → expect 400.
  * Hit with minimal valid body → expect 200 with stub payload.
    Dependencies:
* Step 2 (API folder skeleton).
* Step 7.1, 7.2, 7.3 (utils, Supabase client, auth helpers).

---

Step 7.5 — Scaffold Transactions API Routes
Description:

* Create placeholder endpoints for bank transaction access and batch categorization, mirroring the contracts in the Master Document:

  * `GET /api/companies/:companyId/transactions`
  * `POST /api/companies/:companyId/transactions/categorize` 
* For now they just enforce auth, company scoping, and respond with static/mock data or “stubbed” flags.
  Expected Output:
* Route files under `backend/server/api/companies/[companyId]/transactions/` with:

  * `GET` handler reading query params and returning an empty `transactions: []`.
  * `POST categorize` handler reading `transaction_ids` and returning `{ status: "stubbed", count }`.
* Both use `requireUser()` and ensure `companyId` comes from the URL, ready for RLS-based scoping later.
  Testing Instructions:
* Hit the list endpoint with an authenticated user and a dummy `companyId` → expect 200 with an empty `transactions` array.
* Hit `categorize` with a JSON body containing `transaction_ids` → expect 200 and correct `count` echoed back.
  Dependencies:
* Step 7.3 (auth helper).
* Step 6 (mock UI may eventually call these, but for now only manual testing is needed).

---

Step 7.6 — Scaffold VAT Summary & Returns API Routes
Description:

* Create placeholder VAT endpoints following the Master Document:

  * `GET /api/companies/:companyId/vat/summary`
  * `POST /api/companies/:companyId/vat/returns` 
* They will later compute VAT based on DB data; for now, return hard-coded/sample JSON that matches the final shape.
  Expected Output:
* Route files under `backend/server/api/companies/[companyId]/vat/`:

  * `GET summary` handler reading `period_start`/`period_end` query params and returning a stub summary object with correct keys.
  * `POST returns` handler that accepts period dates and returns a stub `VatReturn`-shaped object.
* Full JSON structure matches the Master Document contracts so frontend wiring later is straightforward.
  Testing Instructions:
* Call `GET /vat/summary?period_start=2025-01-01&period_end=2025-03-31` → ensure JSON includes `total_output_vat`, `total_input_vat`, `net_vat_due`, and `breakdown`.
* Call `POST /vat/returns` with sample dates → ensure a `status: "stubbed"` or similar plus a correctly-shaped `vat_return` object.
  Dependencies:
* Step 7.1 (response helpers).
* Step 7.3 (auth).

---

Step 7.7 — Scaffold Dashboard & Cashflow API Routes
Description:

* Add backend placeholders for the dashboard and cashflow endpoints:

  * `GET /api/companies/:companyId/dashboard/overview`
  * `GET /api/companies/:companyId/cashflow/forecast` 
* Responses should follow the card and forecast shapes defined in the Master Document.
  Expected Output:
* `backend/server/api/companies/[companyId]/dashboard/overview/route.ts` returning:

  * Stubbed values for `cash_balance`, `income_this_month`, `expenses_this_month`, `net_result_this_month`, `runway_days`, `vat_due_current_period`, `insights`.
* `backend/server/api/companies/[companyId]/cashflow/forecast/route.ts` returning:

  * Stubbed `as_of_date`, `series[]`, `burn_rate_monthly`, `runway_days`.
    Testing Instructions:
* Hit `/dashboard/overview` and confirm the response keys match exactly the Master Document’s example.
* Hit `/cashflow/forecast?days=30` and confirm the presence of the `series` array with date/amount pairs.
  Dependencies:
* Step 4 (Dashboard & Cashflow UI skeleton ready to bind later). 
* Step 7.3 (auth).

---

Step 7.8 — Scaffold Chat CFO API Route
Description:

* Create the chat endpoint placeholder:

  * `POST /api/companies/:companyId/chat` 
* For now, ignore real LLM or SQL work; just validate input and return a structured stub message.
  Expected Output:
* `backend/server/api/companies/[companyId]/chat/route.ts` with a `POST` handler that:

  * Reads `{ message, context_limit }` from the body.
  * Uses `requireUser()` and ensures `companyId` is present.
  * Returns a stub response:

    * `assistant_message: "Stubbed Chat CFO response"`
    * `details: {}` or minimal structure matching the contract.
      Testing Instructions:
* From the app or API client, send `POST` with a sample message.
* Confirm you receive `assistant_message` and the HTTP 200 status, or a 400/401 for bad input/unauthenticated requests.
  Dependencies:
* Step 6 (Chat UI already shows fake messages; later, we’ll point it to this endpoint).
* Step 7.3 (auth helper).

---

Step 7.9 — Scaffold Admin API Routes
Description:

* Create placeholder endpoints for internal admin operations:

  * `GET /api/admin/companies/:companyId/review-items`
  * `PATCH /api/admin/transactions/:id` 
* These endpoints will later power the internal admin console.
  Expected Output:
* Route files under `backend/server/api/admin/`:

  * `companies/[companyId]/review-items/route.ts` returning stub lists: `{ transactions: [], documents: [] }`.
  * `transactions/[id]/route.ts` with `PATCH` that reads a JSON body for `category_id`/`vat_code_id` and returns `{ status: "stubbed" }`.
* Both require an authenticated user; for now, role checking can be a TODO comment until roles are modeled in Step 8.
  Testing Instructions:
* Call `GET review-items` as an authenticated non-admin user: currently should still return 200 (we’ll harden later).
* Call `PATCH transactions/:id` with a body `{ "category_id": "test", "vat_code_id": "test" }` → expect 200 and stub response.
  Dependencies:
* Step 4 (Admin screens static).
* Step 7.3 (auth helper).

---

Step 7.10 — Scaffold n8n Inbound Webhook Endpoints
Description:

* Create serverless endpoints dedicated to n8n workflow callbacks, such as file-processing updates, using the orchestration model defined in the Master Document. 
* No real logic yet; just validate that they can be called from n8n with a shared secret.
  Expected Output:
* Route files under `backend/server/api/webhooks/n8n/`, for example:

  * `/api/webhooks/n8n/file-processed`
  * `/api/webhooks/n8n/pipeline-status` (names can be adjusted during naming review).
* Each endpoint:

  * Checks a simple shared secret header or token from `process.env.N8N_WEBHOOK_SECRET`.
  * Returns `{ status: "stubbed" }`.
    Testing Instructions:
* Call the webhook endpoints locally with and without the correct secret header.
* Confirm: correct secret → 200 stub response; missing/incorrect secret → 401/403.
  Dependencies:
* Step 1 (.env includes placeholder n8n secret).
* Step 7.1 (response helpers).

---

Step 7.11 — Implement Outbound n8n Trigger Helper
Description:

* Add a backend helper that other endpoints can later call to trigger n8n workflows (e.g., when a file is uploaded or when categorization should run). 
* For now, it just constructs the URL and performs a simple HTTP POST with minimal payload.
  Expected Output:
* A new helper file, e.g. `backend/lib/pipeline/n8n-client.ts`, exporting:

  * `triggerWorkflow(nameOrId, payload)` that:

    * Reads `N8N_BASE_URL` and `N8N_API_KEY` from env.
    * POSTs `payload` to the appropriate n8n endpoint.
    * Returns a stubbed response or passes through `fetch` result.
* No production routes use this yet, but it compiles.
  Testing Instructions:
* Create a temporary `/api/debug-n8n` route that calls `triggerWorkflow("test", { ping: true })`.
* Hit the route and confirm at least that no runtime error occurs; if a dev test n8n instance exists, verify that it receives the call.
  Dependencies:
* Step 7.1 (response helpers).
* Step 1 (n8n env variables added, even if pointing to a dummy URL initially).

---

Step 7.12 — HUMAN REVIEW: Finalize API Naming & RLS Strategy Notes
Description:

* Perform the “HUMAN REQUIRED” review for Step 7:

  * Walk through all newly scaffolded endpoints and confirm naming conventions, URL patterns, and folder structure match the Master Document (e.g. `/api/companies/:companyId/...`, `/api/files/...`, `/api/admin/...`). 
  * Draft a short RLS strategy note describing how `company_id` scoping and roles (owner/member/admin) will be enforced in Supabase tables in Step 8. 
    Expected Output:
* A short section in `buildlog.md` or `/docs/backend-api.md` that:

  * Lists all current API routes with their HTTP methods and purpose.
  * Confirms or updates any naming decisions.
  * Documents the planned RLS pattern (e.g., “All tables with company data will enforce `company_id = auth.jwt().company_id` for non-admin roles; admin can bypass via service role”).
* Any minor renames applied consistently across route files based on this review.
  Testing Instructions:
* Manually open each route file and ensure the declared URLs match the documented list.
* Ensure the app still builds without errors after any renaming.
  Dependencies:
* All previous sub-steps in Step 7 (7.1–7.11).
* Step 2.7 (previous HUMAN review of folder structure) as context.
